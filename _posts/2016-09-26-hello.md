---
layout: post
title: "Malloc, pointer."
date: 2016-09-26
backgrounds:
    - http://feelgrafix.com/data/background/background-9.jpg
thumb: https://s3.ap-northeast-2.amazonaws.com/matilda38.github.io/screen3.png
categories: C
tags: array malloc
---

1. 문자열 상수는 수정불가능한 char형 배열이다.
2. 배열은 그 자신의 첫번째 원소를 가리키는 포인터 주소값으로 자동 변환된다.

char *str;
str = "abcd";
위 코드는 "abcd"라는 문자열 상수의 첫번째 문자인 a가 저장되있는 주소로 str를 초기화하게 된다.

//문제가 발생하는 코드:
char *str = "abcd";
str[1] = 'b';
str은 a의 주소값을 저장하고 있다.(즉, 문자열 상수를 가르킨다). 그런데 문자열 상수 수정을 시도하고 있기때문에 에러가 나는것이다.

//수정이 가능한 문자열 선언:
char str[] = "abcd";
str[1] = 'b';
이 코드에서는 크기 5의 char형 **배열 str을 만들어서**, 그 안에 'a', 'b', 'c', 'd', '\0' 이라는 내용을 저장하게 됩니다.

코드 1에서 문제가 생기는 이유는, C에서는 문자열 상수가 수정이 불가능하기 때문이고, 코드 2에서 문제가 생기지 않는 이유는, char형 배열은 수정이 가능하기 때문입니다. **str[1]이 가리키는 공간의 성격에 대해 유의할 필요가 있습니다.**

해당 공간이 문자열 상수인지, 배열인지!

메모리 할당 malloc

c 언어에서 프로그램 작성시 포인터를 사용해야할 일이 많았다. 이번 네트워크 과제에서도 header를 가르키는 포인터가 필요했다. 예를 들어,
{%highlight c%}
struct header* header_p;
header_p->flag = FLAG_HELLO;
// 이렇게 포인터를 선언만 해주고 바로 사용하려 했다.
// 이러면 에러난다!
{% endhighlight %}

사실 생각해보면 당연하다. 포인터를 선언해주었는데 초기화를 하지않았으므로 **쓰레기값**이 들어갈테고, 참조할 수 없는 포인터가 될것이다. 참조할 수 없는 포인터의 구조체 변수 flag 값을 대입하라니, segmentation fault가 발생한다.
이때는 *malloc으로 포인터에 주소값을 할당해주는 방법으로 해결할 수 있다*.

{%highlight c%}
struct header* header_p= (struct header*)malloc(sizeof(struct header));
{% endhighlight %}

지긋 지긋했던 segmentation fault 해결!