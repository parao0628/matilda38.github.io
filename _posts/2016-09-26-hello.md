---
layout: post
title: "정보보호."
date: 2016-09-26
backgrounds:
    - http://feelgrafix.com/data/background/background-9.jpg
thumb: http://mblogthumb4.phinf.naver.net/20160315_111/mkhjsk_1458023052522xOxyW_GIF/015.gif?type=w2
categories: C informationSecurity
tags: IS
---

메모리 할당 malloc

표준에서는 단지 문자열 상수(영어로 쓰면 string literal 이므로 '상수'라는 표현은 부정확하다고 볼 수도 있습니다.
토큰 상의 구분으로 볼때 constant와 string literal은 서로 별개입니다)를 수정할 때의 결과는 정의되지 않았다고 표현합니다.
새로 할당한다는 것도 오해의 여지가 있는 표현인데, 새로운 메모리가 할당되는 것이 아니라 기존의 이미 존재하는 공간의 데이터를 수정하는 행동이기 때문입니다.

코드 1과 코드 2의 차이점을 알기 위해서는 다음 사항들을 이해하고 있어야 합니다. 편의상 규칙 1,2,3,4라 이름을 붙이겠습니다.

1. 문자열 상수는 수정불가능한 char형 배열이다.
2. 배열은 그 자신의 첫번째 원소를 가리키는 포인터 주소값으로 자동 변환된다.
3. 2번에는 3가지 예외가 있는데, &연산자의 피연산자, sizeof 연산자의 피연산자, 그리고 char형 배열을 초기화할 때 쓰였을 경우이다.
4. array[2] 는 *(array+2)와 완전히 동일한 표현이다.

한가지 설명을 돕기 위한 예를 들어보이겠습니다.

char *str;
str = "abcd";
위의 코드는 정상일까요? 정상입니다. str은 char형 배열 "abcd"의 첫번째 원소를 가리키는 주소값을 저장하게 됩니다.

char c;
c = "abcd"[2]; // 변수 c에는 'c'가 대입된다.
위의 코드에서 "abcd"[2]는 *("abcd" + 2) 와 같은 뜻입니다. 그런데 "abcd"는 배열이며(규칙1), 그 자신의 첫번째 원소를 가리키는 포인터 주소값으로 자동 변환됩니다. 따라서 "abcd"[2]의 최종 결과값은 "abcd"란 배열의 세번째 원소(인덱스는 0이 첫번째이므로)인 'c'가 됩니다.

그럼 이제 코드 1과 2의 차이점에 대해 알아보겠습니다.

// 코드1:
char *str = "abcd";
str[1] = 'b';
코드 1에서 char *str="abcd"; 의 의미는 char*형 변수 str에 문자열 상수(즉 배열) "abcd"의 첫번째 원소의 주소값을 기억하라는 뜻입니다(규칙2).

//코드 2:
char str[] = "abcd";
str[1] = 'b';
코드 2에서의 "abcd"는 코드 1에서의 "abcd"하고는 의미가 다르며, 일반적인 규칙과는 다른 규칙을 따릅니다(규칙 3을 상기하십시오). 문자열 상수가 char형 배열의 초기화에 쓰일 경우에는, 문자열 상수는 배열로 작용하는 것이 아니라 char형 배열을 초기화 하는데 쓰입니다. 따라서 코드 2에서는 크기 5의 char형 배열 str을 만들어서, 그 안에 'a', 'b', 'c', 'd', '\0' 이라는 내용을 저장하게 됩니다.

코드 1에서 문제가 생기는 이유는, C에서는 문자열 상수가 수정이 불가능(실제로는, 수정을 시도했을 시 그 결과는 정의되어 있지 않음)하기 때문이고, 코드 2에서 문제가 생기지 않는 이유는, char형 배열은 수정이 가능하기 때문입니다. str[1]이 가리키는 공간의 성격에 대해 유의할 필요가 있습니다.

참고로, 문자열 상수에는 한가지 재미있는 특성이 있습니다.

char *s1 = "abc"; // (1)
char *s2 = "abc"; // (2)
char *s3 = "abc"; // (2)
printf("s1=%p, s2=%p, s3=%p", s1, s2, s3);
똑같은 내용의 문자열 상수라면, 컴파일러가 굳이 여러개의 배열을 만들지 않아도 됩니다. 즉, 위의 코드에서 출력되는 s1, s2, s3의 주소값이 동일할 수도 있습니다. 물론 아닐 수도 있고요.
